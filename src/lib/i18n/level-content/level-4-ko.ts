export const LEVEL_4_CONTENT_KO = {
  title: "레벨 4: 최소 변경, 최대 효과",
  subtitle: "작고 집중된 변경이 큰 재작성보다 안전합니다.",
  intro: `작동하는 것이 있습니다. 이제 더 좋게 만들고 싶습니다.

유혹은 더 추가하는 것입니다—더 많은 기능, 더 많은 옵션, 더 많은 영리함. 저항하세요. 최고의 개선은 종종 이미 작동하는 것을 증폭시키는 작고 집중된 변경에서 옵니다.

이 레벨은 자제를 가르칩니다. 더 만드는 것이 잘못되어서가 아니라, 무엇을 바꾸지 않을지 아는 것이 출시하는 사람과 끝없이 만지작거리는 사람을 구분하는 기술이기 때문입니다.`,

  sections: {
    whyMoreIsWorse: {
      title: "더 많은 기능이 보통 제품을 나쁘게 만드는 이유",
      content: `추가하는 모든 기능에는 처음에 보이지 않는 비용이 있습니다.

**사용자에게 복잡함.** 더 많은 버튼은 더 많은 선택을 의미합니다. 더 많은 선택은 더 많은 혼란을 의미합니다. 사용자는 특정한 것을 달성하러 왔습니다—모든 추가 옵션은 그 목표에서 벗어나는 것입니다.

**유지보수 부담.** 모든 기능은 다른 것들을 바꿀 때도 계속 작동해야 합니다. 기능이 많을수록 깨질 수 있는 것이 많고, 개선하는 대신 고치는 데 더 많은 시간을 씁니다.

**희석된 집중.** 모든 것이 중요하면, 아무것도 중요하지 않습니다. 열 가지 기능이 있는 제품은 그중 어느 것도 예외적으로 잘 하지 않습니다. 세 가지 기능이 있는 제품은 그 세 가지를 완벽하게 할 수 있습니다.

**느린 반복.** 큰 제품은 느리게 움직입니다. 작은 제품은 빠르게 방향을 틀고, 조정하고, 피드백에 반응할 수 있습니다. 추가하는 모든 기능이 다음 변경을 더 어렵게 만듭니다.

질문은 "이 기능이 있으면 좋을까요?"가 아닙니다. 그 답은 거의 항상 예입니다. 질문은 "이 기능이 비용을 정당화하나요?"입니다. 그 답은 보통 아니오입니다.`,
      examples: {
        title: "더하기 vs 빼기",
        items: [
          {
            addition: "15개의 사용자 지정 옵션이 있는 설정 페이지 추가",
            subtraction: "최고의 기본값을 선택하고 구성할 필요를 제거",
            lesson: "사용자는 구성하고 싶어하지 않습니다. 그냥 작동하길 원합니다.",
          },
          {
            addition: "키보드 단축키, 터치 제스처, 음성 명령 추가",
            subtraction: "기본 동작을 명확하게 하고 한 번의 클릭으로",
            lesson: "주요 방법이 명확하면 뭔가를 하는 여러 방법은 도움이 안 됩니다.",
          },
          {
            addition: "20개의 지표가 있는 상세한 분석 대시보드 추가",
            subtraction: "실제로 중요한 하나의 숫자를 보여줌",
            lesson: "더 많은 데이터가 더 많은 인사이트가 아닙니다. 올바른 데이터가 인사이트입니다.",
          },
        ],
      },
    },

    highImpactAreas: {
      title: "높은 영향력 영역 식별하기",
      content: `모든 변경이 동등하지 않습니다. 일부 조정은 거대한 개선을 만듭니다. 다른 것들은 거의 등록되지 않습니다. 당신의 일은 높은 영향력 지점을 찾는 것입니다.

높은 영향력 영역은 공통된 특성을 공유합니다:`,
      areas: [
        {
          area: "첫인상",
          description: "사용자가 처음 5초에 보는 것. 헤드라인, 기본 버튼, 초기 상태. 여기서의 작은 개선은 방문하는 모든 사람에게 영향을 미칩니다.",
          example: "버튼을 '제출'에서 '내 결과 받기'로 바꾸면 클릭률이 두 배가 될 수 있습니다. 같은 버튼, 더 좋은 단어.",
        },
        {
          area: "마찰 지점",
          description: "사용자가 망설이거나, 혼란스러워하거나, 포기하는 곳. 에러 메시지, 폼 필드, 로딩 상태.",
          example: "혼란스러운 필드 아래에 한 줄의 도움 텍스트를 추가하면 지원 질문을 절반으로 줄일 수 있습니다.",
        },
        {
          area: "완료 순간",
          description: "사용자가 뭔가를 끝낼 때 일어나는 것. 확인 메시지, 다음 단계, 성공 상태.",
          example: "명확한 '완료되었습니다!' 메시지와 하나의 명확한 다음 동작은 사용자를 혼란스럽게 하는 대신 참여하게 합니다.",
        },
        {
          area: "에러 복구",
          description: "뭔가 잘못될 때 일어나는 것. 에러 메시지, 대안, 재시도 옵션.",
          example: "'Error 500'을 '문제가 발생했습니다. 여기를 클릭해서 다시 시도하세요.'로 바꾸면 좌절이 행동으로 바뀝니다.",
        },
        {
          area: "빈 상태",
          description: "아직 콘텐츠가 없을 때 사용자가 보는 것. 새 계정, 빈 목록, 결과 없음.",
          example: "빈 화면 대신, '아직 할 일이 없습니다. 아래에서 첫 번째를 추가하세요.'와 명확한 프롬프트를 보여주세요.",
        },
      ],
      principle: "곱해지는 곳에 에너지를 집중하세요. 모든 사람이 보는 것에서 10% 개선이 적은 사람들이 도달하는 것에서 50% 개선보다 낫습니다.",
    },

    safeReversibleChanges: {
      title: "안전하고 되돌릴 수 있는 변경 만들기",
      content: `최고의 변경은 작동하지 않으면 되돌릴 수 있는 것입니다.

이것은 소심한 것에 관한 게 아닙니다—스마트한 것에 관한 겁니다. 모든 변경은 가설입니다: "이게 더 나을 거라고 생각해." 때로는 틀립니다. 틀리면, 엉망진창을 디버그하는 게 아니라 작동했던 것으로 돌아가고 싶습니다.`,
      principles: [
        {
          principle: "한 번에 하나씩 바꾸기",
          why: "세 가지를 바꾸고 뭔가 깨지면, 어떤 변경이 원인인지 모릅니다. 하나를 바꾸고, 테스트하고, 확인하고, 그다음에 다음 것을 바꾸세요.",
          how: "변경하기 전에 물어보세요: '이게 하나의 변경인가 아니면 하나로 위장한 여러 변경인가?'",
        },
        {
          principle: "이전 버전 접근 가능하게 유지",
          why: "돌아가야 할 수도 있습니다. 비교하고 싶을 수도 있습니다. 이전 방식이 실제로 더 좋았다는 것을 깨달을 수도 있습니다.",
          how: "변경하기 전에, 현재 상태를 저장하세요. 간단한 복사, 스크린샷, 메모—참조할 수 있는 것.",
        },
        {
          principle: "발표하기 전에 테스트",
          why: "사용자가 보는 깨진 변경은 신뢰를 손상시킵니다. 개인적으로 잡은 깨진 변경은 그냥 학습입니다.",
          how: "변경 후, 아무에게도 말하기 전에 작동하는지 확인하세요. 버튼을 클릭하세요. 폼을 채우세요. 실제로 동작하는 것을 보세요.",
        },
        {
          principle: "변경에 스스로 증명할 시간 주기",
          why: "변경에 대한 첫인상이 항상 정확하지 않습니다. 오늘 이상하게 느껴지는 것이 일주일 후에는 자연스러울 수 있습니다.",
          how: "변경 후, 다른 것을 바꾸기 전에 기다리세요. 사용자가 반응하게 하세요. 무슨 일이 일어나는지 지켜보세요.",
        },
      ],
      warning: "'빨리 하나만 더 고치자'는 충동이 작고 안전한 변경이 크고 엉킨 엉망진창이 되는 방법입니다. 테스트를 포함해서 하나의 변경을 완전히 끝내고 다음을 시작하세요.",
    },

    clarityOverComplexity: {
      title: "복잡함 대신 명확함 개선하기",
      content: `뭔가 작동하지 않을 때, 본능은 더 추가하는 것입니다. 더 많은 설명, 더 많은 옵션, 더 많은 대안.

보통 더 좋은 답은 단순화하는 것입니다.`,
      comparisons: [
        {
          problem: "사용자가 이 버튼이 뭘 하는지 이해 못 함",
          complexSolution: "툴팁, 정보 아이콘, 도움말 링크 추가",
          claritySolution: "명확하도록 버튼 이름 바꾸기",
          lesson: "뭔가를 설명해야 하면, 아마 이름이 잘못된 겁니다.",
        },
        {
          problem: "사용자가 가입 폼을 완료하지 않음",
          complexSolution: "진행 표시기, 저장 후 계속, 이메일 알림 추가",
          claritySolution: "불필요한 필드 세 개 제거",
          lesson: "모든 필드는 포기할 이유입니다. 중요하지 않은 것을 제거하세요.",
        },
        {
          problem: "사용자가 필요한 기능을 못 찾음",
          complexSolution: "검색, 필터, 카테고리, 사이트맵 추가",
          claritySolution: "가장 많이 사용되는 기능을 가장 눈에 띄는 곳에",
          lesson: "정리는 가시성을 고치지 않습니다. 우선순위가 고칩니다.",
        },
        {
          problem: "사용자가 에러 메시지에 혼란스러워함",
          complexSolution: "에러 코드, 문서 링크, 지원 채팅 추가",
          claritySolution: "에러를 명확한 다음 단계와 함께 일반 언어로 작성",
          lesson: "사용자는 에러를 조사하고 싶어하지 않습니다. 고치고 싶어합니다.",
        },
      ],
      summary: "복잡함은 쉽습니다. 명확함은 어렵습니다. 누구나 더 추가할 수 있습니다. 필수적인 것만 남을 때까지 빼는 데는 기술이 필요합니다.",
    },

    communicatingToAI: {
      title: "편집을 요청할 때 AI에게 의도 전달하기",
      content: `AI에게 뭔가 바꾸라고 요청할 때, 변경의 질은 원하는 것—그리고 똑같이 중요하게, 원하지 않는 것—을 얼마나 잘 전달하느냐에 달려 있습니다.

AI는 당신이 제공하지 않으면 사용자, 브랜드, 목표에 대한 맥락이 없습니다. '작은 편집' 요청이 구체적이지 않으면 완전한 재작성으로 바뀔 수 있습니다.`,
      guidelines: [
        {
          guideline: "먼저 현재 동작 설명",
          bad: "제출 버튼 고쳐줘",
          good: "현재 제출 버튼은 '제출'이라고 하고 클릭해도 눈에 보이는 일이 없어. '메시지 보내기'로 바꾸고 처리 중에 '보내는 중...'을 보여줘.",
          why: "AI는 지능적으로 바꾸려면 존재하는 것을 이해해야 합니다.",
        },
        {
          guideline: "변경 범위 명시",
          bad: "폼 개선해줘",
          good: "연락 폼에서, 버튼 텍스트와 로딩 상태만 바꿔. 폼 필드, 유효성 검사, 레이아웃은 수정하지 마.",
          why: "범위 제한 없이, AI가 당신이 그냥 두고 싶었던 것을 '개선'할 수 있습니다.",
        },
        {
          guideline: "작업만이 아니라 목표 설명",
          bad: "에러 메시지 빨간색으로 만들어줘",
          good: "에러 메시지를 더 눈에 띄게 만들어줘. 사용자가 현재 놓치고 있어. 빨간색과 작은 아이콘을 시도해봐, 하지만 전문적으로 유지해.",
          why: "AI가 목표를 이해하면, 어떻게 달성할지 더 좋은 결정을 내릴 수 있습니다.",
        },
        {
          guideline: "'더 좋다'가 당신에게 무엇을 의미하는지 정의",
          bad: "이거 더 좋게 만들어줘",
          good: "이거 더 스캔하기 쉽게 만들어줘. 사용자가 모든 것을 읽지 않고 3초 안에 요점을 이해할 수 있어야 해.",
          why: "'더 좋다'는 주관적입니다. 당신의 '더 좋다' 정의가 AI의 기본값과 다를 수 있습니다.",
        },
      ],
      template: {
        title: "편집 요청 템플릿",
        content: `여기 집중된 편집을 요청하는 구조가 있습니다:

**현재 상태:** [지금 존재하는 것]
**문제:** [바꿔야 하는 이유]
**원하는 변경:** [구체적으로 무엇이 달라야 하는지]
**범위:** [바뀌지 않아야 하는 것]
**성공은:** [작동했다는 것을 어떻게 알 것인지]`,
        example: `현재 상태: 폼 제출 후 확인 메시지가 그냥 "제출됨."
문제: 사용자가 작동했는지 확신 못 하고 다음에 무슨 일이 일어나는지 모름.
원하는 변경: 성공을 확인하고 기대할 것을 알려주는 메시지로 바꿈.
범위: 확인 메시지 텍스트만 바꿈. 폼 자체를 바꾸거나 새 요소를 추가하지 않음.
성공은: 제출 후, 사용자가 제출이 접수되었고 다음에 무슨 일이 일어나는지 말하는 친근한 메시지를 봄 (예: "감사합니다! 24시간 내에 답변 드리겠습니다.").`,
      },
    },

    smallChangeBigResult: {
      title: "작은 변경, 큰 결과",
      intro: "이 예시들은 최소한의 변경이 어떻게 사용자 경험을 극적으로 개선할 수 있는지 보여줍니다. 새 기능이 필요한 것은 하나도 없습니다—존재하는 것을 더 잘 실행할 뿐입니다.",
      examples: [
        {
          change: "버튼 텍스트: '제출' → '무료 가이드 받기'",
          impact: "사용자가 무엇을 하는지가 아니라 무엇을 얻는지 보기 때문에 더 클릭함",
          effort: "몇 단어 바꾸는 데 5초",
        },
        {
          change: "에러 메시지: '잘못된 입력' → '유효한 이메일 주소를 입력해 주세요'",
          impact: "사용자가 뭐가 잘못됐는지 추측하는 대신 문제를 고칠 수 있음",
          effort: "도움되는 문장 쓰는 데 10초",
        },
        {
          change: "빈 상태: 빈 화면 → '아직 항목이 없습니다. 여기서 추가하는 방법입니다.'",
          impact: "새 사용자가 뭔가 고장났다고 생각하는 대신 무엇을 해야 하는지 이해함",
          effort: "도움되는 한 줄 쓰는 데 30초",
        },
        {
          change: "폼 필드: '이름' → '성명 (신분증에 나오는 대로)'",
          impact: "사용자가 처음에 올바른 정보를 입력해서 왔다 갔다가 줄어듦",
          effort: "명확한 텍스트 추가하는 데 15초",
        },
        {
          change: "로딩 상태: 빈 멈춤 → '결과 로딩 중...'",
          impact: "사용자가 앱이 멈췄는지 궁금해하는 대신 작동하고 있다는 것을 앎",
          effort: "로딩 메시지 추가하는 데 10초",
        },
        {
          change: "성공 메시지: '완료' → '저장됐습니다! 이 창을 닫아도 됩니다.'",
          impact: "사용자가 마무리가 있고 다음에 뭘 해야 하는지 앎",
          effort: "완전한 메시지 쓰는 데 10초",
        },
      ],
      observation: "패턴을 주목하세요: 이 변경들 중 기능을 추가하는 것은 없습니다. 명확함을 추가합니다. 몇 시간이 아니라 몇 초가 걸립니다. 그리고 사용자가 제품을 경험하는 방식에 과도한 영향을 미칩니다.",
    },

    changeVsLeaveAlone: {
      title: "바꿀 것 vs 그냥 둘 것",
      intro: "변경을 하고 싶을 때 이것을 결정 프레임워크로 사용하세요.",
      change: {
        title: "이것을 바꾸세요",
        items: [
          {
            item: "사용자를 혼란스럽게 하는 단어들",
            reason: "명확한 언어는 무료이고 높은 영향력입니다. 전달되지 않는 버튼 텍스트, 라벨, 에러 메시지, 지침을 바꾸세요.",
          },
          {
            item: "누락된 피드백",
            reason: "사용자가 뭔가 하고 눈에 보이는 일이 없으면, 피드백을 추가하세요. 로딩 상태, 확인, 에러 메시지.",
          },
          {
            item: "깨진 흐름",
            reason: "사용자가 막히거나 길을 잃으면, 경로를 고치세요. 하지만 구체적인 깨진 부분을 고치세요—전체 흐름을 재설계하지 말고.",
          },
          {
            item: "플레이스홀더 콘텐츠",
            reason: "'Lorem ipsum'이나 'TODO'를 어디든 남겼으면, 실제 콘텐츠로 교체하세요. 플레이스홀더 텍스트는 사용자를 혼란스럽게 하고 프로페셔널하지 않아 보입니다.",
          },
          {
            item: "명백한 오류",
            reason: "오타, 깨진 링크, 잘못된 색상—명확한 실수인 것들. 과하게 생각하지 말고 고치세요.",
          },
        ],
      },
      leaveAlone: {
        title: "이것은 그냥 두세요",
        items: [
          {
            item: "적극적으로 사용하지 않는 작동하는 기능",
            reason: "작동하고 지금 그 위에 만들고 있지 않으면, 건드리지 마세요. 아무도 없는 문제를 해결하다 버그를 도입하게 됩니다.",
          },
          {
            item: "완전히 이해하지 못하는 코드 구조",
            reason: "이해하지 못하는 코드를 재구성하면 혼돈이 됩니다. 작동하면, 작동한다는 것을 존중하세요.",
          },
          {
            item: "'괜찮은' 디자인 선택",
            reason: "'괜찮음'은 과소평가됩니다. 뭔가 괜찮지만 완벽하지 않으면, 넘어가세요. 완벽은 출시의 적입니다.",
          },
          {
            item: "'충분히 빠른' 성능",
            reason: "사용자를 짜증나게 할 만큼 느리지 않으면, 충분히 빠릅니다. 문제 없는 최적화는 그냥 만지작거리기입니다.",
          },
          {
            item: "'언젠가' 필요할 수도 있는 기능",
            reason: "언젠가는 절대 안 옵니다. 가상의 미래 사용을 위해 기능을 만들거나 유지하거나 다듬지 마세요. 오늘의 사용자를 위해 만드세요.",
          },
        ],
      },
      mantra: "사용자를 막는 것을 바꾸세요. 그들을 섬기는 것은 그냥 두세요. 출시하고 넘어가세요.",
    },
  },

  closing: `자제는 경쟁 우위입니다.

다른 사람들이 기능을 계속 추가하면서 사용자가 왜 참여하지 않는지 궁금해할 때, 당신은 존재하는 것을 실제로 작동하게 만드는 데 집중할 것입니다. 다른 사람들이 일이 엉망이 되면 처음부터 다시 만들 때, 당신은 시간이 지남에 따라 복리가 되는 집중된 개선을 할 것입니다.

작은 변경을 하는 훈련—그리고 나머지는 그냥 두는—이 지속 가능한 제품을 만드는 사람과 자체 무게로 무너지는 모래성을 만드는 사람을 구분합니다.

레벨 4에서, 제품 개발에서 가장 어려운 교훈을 배웠습니다: 때때로 당신이 할 수 있는 최선은 거의 아무것도 아닙니다. 하지만 그 "거의 아무것도"가 정확히 맞는 것이어야 합니다.

이제 레벨 5로 갈 준비가 됐습니다. 개별 변경에서 줌아웃해서 제품 전체로 생각합니다.`,
};
