export const LEVEL_2_CONTENT_KO = {
  title: "레벨 2: AI에게 프롬프트로 지시하기",
  subtitle: "AI는 당신의 주니어 개발자입니다. 당신이 매니저입니다.",
  intro: `만들고 싶은 것을 정의했습니다. 이제 결과를 얻을 수 있는 방식으로 AI에게 전달해야 합니다.

마법의 단어나 비밀 기술에 관한 게 아닙니다. 구조, 명확함, 그리고 AI를 능력 있지만 말 그대로 받아들이는 협력자로 대하는 것에 관한 것입니다.

답답한 AI 세션과 생산적인 세션의 차이는 보통 무엇을 물어보느냐가 아니라 어떻게 물어보느냐에서 옵니다.`,

  sections: {
    whyDoEverythingFails: {
      title: "'전부 해줘' 프롬프트가 실패하는 이유",
      content: `가장 흔한 실수: 전체 비전을 하나의 프롬프트에 쏟아붓고 최선을 바라는 것.

"캘린더 뷰, 고객 계정, 이메일 알림, 결제 처리, 관리자 대시보드가 있는 완전한 예약 시스템을 만들어줘."

이것은 여러 이유로 실패합니다:

**AI가 집중을 잃습니다.** 한 번에 더 많이 요청할수록, AI가 각 부분에서 대충할 가능성이 높아집니다. 모든 것을 만족시키려 하니, 아무것도 잘 만족시키지 못합니다.

**방향 수정을 할 수 없습니다.** 모든 것이 한꺼번에 나오면, 어느 부분이 잘못됐는지 알 수 없습니다. 캘린더? 계정? 결제? 고치는 대신 처음부터 다시 시작하게 됩니다.

**맥락이 희석됩니다.** AI는 작업 메모리가 있습니다. 열 가지 기능으로 채우면, 각각의 세부사항이 흐릿해집니다. 한 번에 하나씩 물어보면, 그 하나에 AI의 전체 집중을 얻습니다.

**생각을 건너뜁니다.** 한 번에 모든 것을 요청하는 것은 보통 순서를 생각하지 않았다는 뜻입니다. 먼저 무엇이 일어나야 하나요? 무엇이 무엇에 의존하나요? AI는 그것을 대신 알아낼 수 없습니다.

해결책은 덜 요청하는 게 아닙니다. 순서대로 요청하는 것입니다—한 번에 하나의 명확한 요청, 다음으로 넘어가기 전에 출력을 검토합니다.`,
      badExample: {
        label: "'전부 해줘' 프롬프트",
        prompt: "사용자 인증, 제목과 마감일이 있는 할 일 생성, 카테고리, 우선순위, 반복 할 일, 팀 공유, 알림, 캘린더 뷰, 다크 모드 토글이 있는 완전한 할 일 관리 앱을 만들어줘. 모던하고 프로페셔널하게 보이게.",
        whyItFails: [
          "너무 많은 기능이 관심을 두고 경쟁",
          "가장 중요한 것이 무엇인지 표시 없음",
          "순서나 의존성 정의 없음",
          "뭔가 잘못됐을 때 검토하거나 디버그 불가능",
          "AI가 각 기능에 대해 임의로 결정할 것임",
        ],
      },
    },

    assigningRoles: {
      title: "AI에게 역할 부여하기",
      content: `말하지 않으면 AI는 어떤 종류의 도움이 필요한지 모릅니다. 같은 요청도 부여하는 역할에 따라 매우 다른 응답을 받습니다.

채용처럼 생각하세요. "누군가"에게 프로젝트를 도와달라고 하지 않을 겁니다. 프론트엔드 개발자, 디자이너, 카피라이터를 고용할 겁니다—각각 다른 관점을 가져옵니다.

역할을 부여하면 두 가지가 됩니다:
1. AI의 지식을 관련된 것에 집중시킴
2. 응답의 톤과 형식을 설정함`,
      roles: [
        {
          role: "당신은 프론트엔드 개발자입니다",
          effect: "AI가 코드 구조, 사용자 인터페이스, 브라우저 동작에 집중합니다. 응답에 코드가 포함됩니다.",
          useWhen: "뭔가 만들어지거나 구현되어야 할 때.",
        },
        {
          role: "당신은 코드 리뷰어입니다",
          effect: "AI가 문제, 불일치, 개선점을 찾습니다. 더 비판적이고, 덜 창의적입니다.",
          useWhen: "코드가 있고 사용하기 전에 피드백을 원할 때.",
        },
        {
          role: "당신은 UX 컨설턴트입니다",
          effect: "AI가 사용자 경험, 흐름, 사용성에 집중합니다. 코드 적음, 구조와 추론 더 많음.",
          useWhen: "무엇을 만들지 결정할 때, 어떻게 만들지가 아닌.",
        },
        {
          role: "당신은 테크니컬 라이터입니다",
          effect: "AI가 명확하게 설명하고, 전문 용어를 피하고, 이해를 위해 정보를 구조화합니다.",
          useWhen: "AI가 만든 것이 무엇인지 또는 왜 작동하는지 이해해야 할 때.",
        },
      ],
      tip: `대화 중에 역할을 바꿀 수 있습니다. "프론트엔드 개발자"로 뭔가를 만들고, "코드 리뷰어"로 바꿔서 자신의 작업을 확인하세요. 다른 관점이 다른 문제를 잡습니다.`,
    },

    breakingIntoSteps: {
      title: "작업을 단계로 나누기",
      content: `효과적인 프롬프팅의 핵심은 순서입니다. 하나의 거대한 요청 대신, 작업을 단계로 나눕니다—각각 다음으로 넘어가기 전에 검토할 수 있을 만큼 작게.

이게 더 느리지 않습니다. 더 빠릅니다. 문제를 일찍, 고치기 쉬울 때 잡습니다. 불안정한 기초가 아닌 작동하는 기초 위에 구축합니다.`,
      principle: `각 프롬프트는 한 가지를 해야 합니다. 그 일이 끝나고 확인되면, 다음으로 넘어갑니다.`,
      goodExample: {
        label: "다단계 접근 방식",
        context: "웹사이트를 위한 간단한 연락 폼을 만들고 있습니다.",
        steps: [
          {
            step: 1,
            prompt: "이름, 이메일, 메시지 세 개의 필드가 있는 연락 폼 컴포넌트를 만들어줘. 모든 필드는 필수야. 심플하고 깔끔한 디자인으로. 제출 로직은 아직 신경 쓰지 마—폼 구조와 기본 스타일링만.",
            why: "구조만으로 시작합니다. 폼 만들기와 폼 처리를 섞지 않습니다.",
          },
          {
            step: 2,
            prompt: "이제 클라이언트 사이드 유효성 검사를 추가해. 이름은 최소 2자. 이메일은 유효한 이메일 형식이어야 해. 메시지는 최소 10자. 유효성 검사가 실패하면 각 필드 아래에 에러 메시지를 보여줘.",
            why: "기능의 한 레이어를 추가합니다. 넘어가기 전에 유효성 검사를 테스트할 수 있습니다.",
          },
          {
            step: 3,
            prompt: "모든 필드가 유효할 때 폼 데이터를 콘솔에 로그하는 제출 핸들러를 추가해. '제출 중'에 로딩 상태를 보여주고 그 후에 성공 메시지를 보여줘. 나중에 실제 백엔드에 연결할 거야.",
            why: "제출을 따로 처리합니다. 콘솔 로깅으로 아직 백엔드 없이도 작동하는지 확인할 수 있습니다.",
          },
          {
            step: 4,
            prompt: "이 컴포넌트에 문제가 있는지 검토해줘. 접근성 문제, 내가 놓쳤을 수 있는 엣지 케이스, 더 깔끔할 수 있는 코드를 확인해줘.",
            why: "리뷰어 역할로 전환합니다. 더 만들기 전에 문제를 잡습니다.",
          },
        ],
        contrast: "'유효성 검사, 제출, 로딩 상태, 성공 메시지, 에러 처리가 있는 연락 폼'을 한 번에 요청하는 것과 비교해 보세요. 같은 최종 결과지만, 다단계 접근 방식은 다음을 추가하기 전에 각 부분이 작동하는지 확인할 수 있습니다.",
      },
    },

    reviewingOutput: {
      title: "넘어가기 전에 AI 출력 검토하는 법",
      content: `AI는 맞아 보이는 것을 줄 겁니다. 당신의 일은 그 위에 구축하기 전에 실제로 맞는지 확인하는 것입니다.

코드의 모든 줄을 이해할 필요는 없습니다. 출력이 요청한 것과 일치하고 예상대로 작동하는지 확인해야 합니다.`,
      reviewChecklist: [
        {
          check: "내가 요청한 것과 일치하나?",
          how: "프롬프트를 다시 읽으세요. AI가 만든 것과 비교하세요. 모든 것이 포함됐나요? 요청하지 않은 것이 추가됐나요?",
        },
        {
          check: "작동하는 것을 볼 수 있나?",
          how: "실행하고, 클릭하고, 테스트하세요. 코드만 읽지 말고—실제로 동작하는 것을 보세요. 버튼이 실제로 뭔가를 하나요? 폼이 실제로 유효성 검사를 하나요?",
        },
        {
          check: "구조가 이해되나?",
          how: "코드를 깊이 이해하지 않아도, 조직을 볼 수 있습니다. 논리적으로 그룹화되어 있나요? 다른 부분이 무엇을 하는지 설명하는 주석이 있나요?",
        },
        {
          check: "명백한 실수가 있나?",
          how: "대체되지 않은 플레이스홀더 텍스트, 동적이어야 하는데 하드코딩된 값, 존재하지 않는 것에 대한 참조 같은 것을 찾으세요.",
        },
        {
          check: "AI가 어떤 가정을 했나?",
          how: "AI는 지정하지 않은 빈틈을 채웁니다. 괜찮습니다—하지만 무엇을 가정했는지 알아야 합니다. 물어보세요: '이 구현에서 어떤 가정을 했어?'",
        },
      ],
      whenToStop: `뭔가 이상해 보이면, 계속하기 전에 멈추고 고치세요. 깨진 기초 위에 구축하면 시간 낭비입니다. 5단계 후에 디버그하는 것보다 한 단계 뒤로 가는 게 더 빠릅니다.`,
    },

    iterationAsWorkflow: {
      title: "반복은 정상적인 워크플로우",
      content: `첫 번째 시도에 맞추는 것은 드뭅니다. 반복은 실패가 아닙니다—과정입니다.

전문 개발자도 즉시 완벽한 코드를 작성하지 않습니다. 뭔가를 쓰고, 테스트하고, 문제를 찾고, 고치고, 반복합니다. Vibe coding도 같은 방식으로 작동하지만, AI가 작성하고 당신이 지시합니다.`,
      iterationTypes: [
        {
          type: "개선",
          description: "출력이 가깝지만 완전히 맞지 않습니다.",
          example: "'버튼 색이 너무 어두워. 흰색 텍스트와 대비가 더 좋은 밝은 파란색으로 바꿔줘.'",
          mindset: "작은 조정. 재구축이 아닌 다듬기입니다.",
        },
        {
          type: "수정",
          description: "뭔가 잘못되었거나 빠졌습니다.",
          example: "'필드가 비어 있어도 폼이 제출돼. 유효성 검사가 작동 안 해. 빈 필드가 제출 대신 에러를 보여주도록 유효성 검사를 고쳐줘.'",
          mindset: "구체적인 문제를 가리킵니다. AI에게 뭐가 잘못됐는지 추측하라고 하지 마세요.",
        },
        {
          type: "확장",
          description: "현재 부분이 작동하고, 이제 추가하는 것입니다.",
          example: "'폼이 작동해. 이제 사용자가 '초기화' 버튼을 클릭하면 모든 필드를 지우는 기능을 추가해줘.'",
          mindset: "현재 부분이 확인된 후에만 확장합니다. 깨진 코드에 추가하지 마세요.",
        },
        {
          type: "방향 전환",
          description: "접근 방식이 작동하지 않고 다른 방향이 필요하다는 것을 깨달았습니다.",
          example: "'이게 내가 생각한 게 아니야. 다른 접근 방식을 시도해보자. 다단계 폼 대신, 모든 필드가 보이는 단일 페이지로 만들어줘.'",
          mindset: "방향을 바꿔도 괜찮습니다. 나쁜 길에 몰두하는 것보다 일찍 전환하는 게 낫습니다.",
        },
      ],
      normalizing: `반복을 예상하세요. 첫 번째 시도에 완벽한 것을 얻으면, 그건 운입니다—정상이 아닙니다. 대부분의 프롬프트는 만족할 때까지 2-4번 반복합니다. 괜찮습니다. 각 반복은 빠르고, 미래 프로젝트에 무엇이 작동하는지 배우는 것입니다.`,
    },

    promptingCorrectly: {
      title: "제대로 프롬프팅하고 있다는 신호",
      description: "이 체크리스트를 사용해서 프롬프팅 접근 방식을 평가하세요:",
      signs: [
        {
          sign: "각 프롬프트가 한 가지에 집중한다",
          detail: "한 번에 다섯 가지 기능을 요청하지 않습니다. 하나의 요청, 하나의 결과.",
        },
        {
          sign: "출력을 보기 전에 기대하는 것을 설명할 수 있다",
          detail: "'성공'이 어떤 모습인지 말로 표현할 수 없다면, 프롬프트가 충분히 명확하지 않습니다.",
        },
        {
          sign: "위에 구축하기 전에 출력을 검토한다",
          detail: "맹목적으로 프롬프트를 쌓지 않습니다. 각 단계가 작동하는지 확인합니다.",
        },
        {
          sign: "반복이 모호하지 않고 구체적이다",
          detail: "'버튼 고쳐줘'는 모호합니다. '버튼이 호버할 때 색이 안 바뀌어—호버 상태를 추가해줘'는 구체적입니다.",
        },
        {
          sign: "필요할 때 맥락을 제공한다",
          detail: "AI가 무엇을 만들고 있는지 알고 있습니다. 상기시켜줬기 때문입니다. '우리가 만든 연락 폼에서, 추가해줘...'",
        },
        {
          sign: "작업을 전환할 때 역할을 부여한다",
          detail: "빌더 모드는 만들 때. 리뷰어 모드는 검토할 때. AI가 동시에 둘 다 하길 기대하지 않습니다.",
        },
        {
          sign: "'그거 맞지 않아, 다시 해봐'라고 편하게 말한다",
          detail: "반복에 좌절하지 않습니다. 예상하고 직접적으로 처리합니다.",
        },
        {
          sign: "적절할 때 작은 편집을 직접 한다",
          detail: "색 바꾸기나 오타 고치기는 프롬프트가 필요 없습니다. 사소한 변경은 직접 처리합니다.",
        },
      ],
    },
  },

  closing: `프롬프팅은 기술입니다. 연습하면 나아질 것입니다.

구조로 시작하세요: 한 번에 하나의 요청, 넘어가기 전에 검토, 필요에 따라 반복. 이것을 더 많이 할수록, 얼마나 요청해야 하는지, 얼마나 맥락을 줘야 하는지, 언제 AI의 출력에 이의를 제기해야 하는지에 대한 직관이 발달합니다.

지금은 순서에 집중하세요. 명확한 요청. 출력 검토. 다음 단계.

그것이 생산적인 AI 협업의 리듬입니다.`,
};
