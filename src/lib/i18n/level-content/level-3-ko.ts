export const LEVEL_3_CONTENT_KO = {
  title: "레벨 3: 코드 읽고 판단하기",
  subtitle: "코드를 작성할 필요 없습니다. 판단할 줄 알면 됩니다.",
  intro: `AI가 코드를 씁니다. 당신은 그게 좋은지 결정합니다.

프로그래머가 되는 것에 관한 게 아닙니다. AI가 만든 것을 보고 "응, 이거 맞는 것 같아" 또는 "아니, 뭔가 이상해"라고 말할 수 있을 만큼의 직관을 기르는 것입니다.

다른 분야에서도 이미 이렇게 합니다. 인테리어 디자이너가 아니어도 방이 잘 디자인됐는지 알 수 있습니다. 정비사가 아니어도 차가 제대로 작동하지 않는지 느낄 수 있습니다. 코드도 마찬가지입니다—패턴이 나타나고, 인식하는 법을 배웁니다.`,

  sections: {
    whyYouDontNeedToWrite: {
      title: "코드를 작성하지 않아도 판단할 수 있는 이유",
      content: `쓰기와 읽기는 다른 기술입니다.

영화 평론가가 영화를 감독할 필요는 없습니다. 음식 평론가가 전문적으로 요리할 필요는 없습니다. 편집자가 편집하는 책을 쓸 필요는 없습니다. 그들의 일은 창작이 아닌 평가입니다.

당신의 일도 같습니다. AI가 창작합니다. 당신이 평가합니다.

이것이 작동하는 이유는 대부분의 코드 문제가 알기 어려운 기술적 세부사항에 숨어 있지 않기 때문입니다. 구조, 조직, 명백한 패턴에서 보입니다. 이게 정리된 것 같나 혼란스러운가? 이름이 명확한가? 흐름이 이해되나?

모든 줄을 이해하지 않아도 이 질문들에 답할 수 있습니다.

목표는 코드를 완벽하게 이해하는 게 아닙니다. 목표는 다음을 할 수 있을 만큼 충분히 이해하는 것입니다:
- 요청한 대로 됐는지 알기
- 더 큰 문제가 되기 전에 명백한 문제 발견하기
- 뭔가 이상해 보일 때 지능적인 질문하기
- 언제 AI 작업을 신뢰하고 언제 이의를 제기할지 결정하기

처음부터 코드를 쓰는 것보다 낮은 기준입니다. 달성 가능합니다. 그리고 충분합니다.`,
    },

    buildingMetaphor: {
      title: "코드를 건물로 보기",
      intro: "코드를 물리적 구조물—집, 사무실, 건물—처럼 생각하세요. 이 비유가 기술 지식 없이도 보고 있는 것을 이해하는 데 도움이 됩니다.",
      comparisons: [
        {
          building: "기초",
          code: "핵심 설정과 구성",
          meaning: "건물이 벽을 올리기 전에 튼튼한 기초가 필요하듯, 코드도 기능을 만들기 전에 적절한 설정이 필요합니다. AI가 이것을 건너뛰거나 대충 하면, 그 위에 만들어진 모든 것이 불안정합니다.",
          whatToLook: "찾을 것: 프로젝트를 설정하고, 설정을 구성하고, 다른 부분들이 어떻게 연결되는지 정하는 파일. 이것들이 존재하고 정리되어 보여야 합니다, 급하게 한 게 아니라.",
        },
        {
          building: "방과 복도",
          code: "파일과 폴더",
          meaning: "잘 설계된 건물은 명확한 복도로 연결된 논리적인 방들이 있습니다. 나쁘게 설계된 건물은 무작위 방, 막다른 길, 혼란스러운 경로가 있습니다. 코드도 마찬가지—파일이 논리적으로 그룹화되어 있어야 하고, 관련 조각들 사이에 명확한 경로가 있어야 합니다.",
          whatToLook: "찾을 것: 이해되는 폴더 이름, 목적별로 그룹화된 파일, 지도 없이도 탐색할 수 있는 구조.",
        },
        {
          building: "라벨이 붙은 문",
          code: "이름이 붙은 함수와 컴포넌트",
          meaning: "좋은 건물에서 문에는 라벨이 있습니다. 열기 전에 뒤에 뭐가 있는지 압니다. 좋은 코드에서 것들은 명확하게 이름이 붙어 있습니다. 'handleSubmit'은 무엇을 하는지 알려줍니다. 'processData'는 아무것도 알려주지 않습니다.",
          whatToLook: "찾을 것: 무엇을 하는지 설명하는 이름, 'helper', 'utils', 또는 한 글자 같은 모호한 라벨이 아닌.",
        },
        {
          building: "전기와 배관",
          code: "로직과 데이터 흐름",
          meaning: "건물에서 배선을 보지 않지만, 조명이 켜지고 물이 흐르기 때문에 작동한다고 신뢰합니다. 코드에서 모든 선을 추적할 필요는 없습니다—하지만 뭔가 작동하지 않을 때, '배관'에 문제가 있다는 것을 압니다.",
          whatToLook: "찾을 것: 버튼을 클릭하면 예상대로 되나요? 데이터가 있어야 할 곳에 나타나나요? 아니라면, 내부 배선에 문제가 있습니다.",
        },
        {
          building: "비상구",
          code: "에러 처리",
          meaning: "좋은 건물은 명확하게 표시된 비상구가 있습니다. 좋은 코드는 뭔가 잘못될 때를 처리하는 방법이 있습니다—에러 메시지, 대안, 복구 경로. 나쁜 코드는 아무것도 절대 실패하지 않을 것이라고 가정합니다.",
          whatToLook: "찾을 것: 뭔가 잘못되면 어떻게 되나요? 앱이 크래시되나요, 아니면 도움이 되는 메시지를 보여주나요? '이게 실패하면?' 고려가 있나요?",
        },
      ],
      summary: "비상구가 없고, 복도가 혼란스럽고, 문에 라벨이 없는 건물을 알아채는 데 건축가가 될 필요 없습니다. 코드에서 같은 문제를 알아채는 데 프로그래머가 될 필요 없습니다.",
    },

    structureVsChaos: {
      title: "구조 vs 혼돈 인식하기",
      content: `코드를 볼 때, 조직의 신호—또는 그 부재의 신호—를 찾고 있습니다.

코드가 무엇을 하는지 이해할 필요 없이 어떻게 조직되어 있는지 볼 수 있습니다. 책장을 보는 것과 같습니다: 책을 하나도 읽지 않았어도 주제별로 정리되어 있는지 무작위로 던져져 있는지 알 수 있습니다.`,
      signs: {
        structure: {
          title: "좋은 구조의 신호",
          items: [
            {
              sign: "일관된 패턴",
              description: "비슷한 것들이 비슷한 방식으로 됩니다. 버튼이 한 곳에서 한 방식으로 만들어지면, 어디서나 같은 방식으로 만들어집니다.",
            },
            {
              sign: "명확한 그룹화",
              description: "관련 코드가 함께 있습니다. 모든 폼 관련 코드가 한 곳에, 모든 네비게이션 코드가 다른 곳에.",
            },
            {
              sign: "설명적인 이름",
              description: "이름에서 무엇을 하는지 추측할 수 있습니다. 'calculateTotal', 'showErrorMessage', 'userEmail'은 무엇인지 알려줍니다.",
            },
            {
              sign: "적절한 크기",
              description: "아무것도 불합리하게 거대하지 않습니다. 수백 줄이 되는 단일 코드 조각은 보통 너무 많은 것을 하고 있습니다.",
            },
            {
              sign: "필요한 곳에 주석",
              description: "특이하거나 복잡한 부분에 간단한 설명이 있습니다. 모든 줄에 주석이 있는 게 아니라—맥락이 필요한 부분에만.",
            },
          ],
        },
        chaos: {
          title: "혼돈의 신호",
          items: [
            {
              sign: "불일치",
              description: "같은 것이 세 곳에서 세 가지 다른 방식으로 됩니다. 따를 패턴이 없습니다.",
            },
            {
              sign: "모든 것이 한 파일에",
              description: "수백 또는 수천 줄이 함께 뭉쳐져 있습니다. 분리 없음, 조직 없음.",
            },
            {
              sign: "알 수 없는 이름",
              description: "'x', 'temp', 'data2', 'thing'이라는 변수. 무엇을 처리하거나 다루는지 표시 없이 'process'나 'handle'이라는 함수.",
            },
            {
              sign: "주석 처리된 코드",
              description: "'꺼졌지만' 그 자리에 남겨진 큰 코드 블록. 불확실함과 지저분함의 신호.",
            },
            {
              sign: "에러 처리 없음",
              description: "모든 것이 항상 완벽하게 작동할 것이라고 가정하는 코드. '이게 실패하면?' 고려가 없음.",
            },
          ],
        },
      },
      advice: "혼돈을 보면, 직접 고치려 하지 마세요. AI에게 지적하세요: '이 파일이 너무 길고 따라가기 어려워. 더 작고 명확하게 이름 붙은 섹션으로 재구성해줄 수 있어?' AI가 재구조화하게 하세요—당신의 일은 문제를 알아채는 것입니다.",
    },

    redFlags: {
      title: "위험하거나 취약한 영역 식별하기",
      intro: "일부 코드 문제는 위험합니다. 지금은 작동할 수 있지만 나중에 깨지거나, 당신에게는 작동하지만 다른 사람에게는 실패할 수 있습니다. 이 위험 신호를 발견하는 법을 배우세요.",
      flags: [
        {
          flag: "유연해야 하는데 하드코딩된 값",
          example: "적절한 관리자 설정을 확인하는 대신 '사용자가 john@email.com이면 관리자 패널을 보여줘'라고 하는 코드.",
          risk: "특정 경우에만 작동하고 조건이 바뀌면 바로 깨집니다.",
          question: "AI에게 물어보세요: '여기 구성 가능해야 하는데 하드코딩된 값이 있어?'",
        },
        {
          flag: "입력 유효성 검사 없음",
          example: "무엇을 입력하든 이해되는지 확인하지 않고 받아들이는 폼.",
          risk: "사용자가 쓰레기 데이터를 입력하고, 시스템을 깨뜨리거나, 예상치 못한 동작을 일으킬 수 있습니다.",
          question: "AI에게 물어보세요: '사용자가 예상치 못한 또는 유효하지 않은 데이터를 입력하면 어떻게 돼?'",
        },
        {
          flag: "강한 결합",
          example: "작은 것 하나를 바꾸면 열 가지 다른 것을 바꿔야 함.",
          risk: "시스템이 취약합니다. 작은 변경이 문제의 연쇄 반응을 일으킵니다.",
          question: "AI에게 물어보세요: 'X를 바꾸고 싶으면, 몇 군데나 바꿔야 해?'",
        },
        {
          flag: "불명확한 의존성",
          example: "신비롭게 다른 코드가 먼저 실행되어야 하는 코드, 하지만 이게 명확하지 않음.",
          risk: "우연히 작동합니다. 뭔가 재정렬하면 모든 것이 깨집니다.",
          question: "AI에게 물어보세요: '이 코드가 먼저 실행되어야 하는 것에 의존해? 그게 안 일어나면 어떻게 돼?'",
        },
        {
          flag: "낙관적 가정",
          example: "네트워크가 항상 작동하고, 데이터베이스가 항상 응답하고, 사용자가 항상 잘 행동한다고 가정하는 코드.",
          risk: "현실에서 모든 것은 때때로 실패합니다. 실패를 처리하지 않는 코드는 크래시됩니다.",
          question: "AI에게 물어보세요: '[외부 것]이 실패하거나 사용 불가능하면 어떻게 돼?'",
        },
        {
          flag: "모호함에 의한 보안",
          example: "민감한 기능이 적절히 보호되지 않고 '숨겨져' 있음.",
          risk: "숨기는 것은 보호하는 게 아닙니다. 찾아보는 사람은 누구나 찾아서 악용할 수 있습니다.",
          question: "AI에게 물어보세요: '적절한 권한 없이 접근 가능한 민감한 데이터나 기능이 있어?'",
        },
      ],
      note: "이 문제들의 기술적 세부사항을 이해할 필요 없습니다. 존재한다는 것을 알고 AI에게 물어보면 됩니다. AI가 이 문제들을 식별하고 고칠 수 있습니다—하지만 물어봐야만 합니다.",
    },

    whenNotToTouch: {
      title: "작동하는 코드를 건드리지 말아야 할 때 알기",
      content: `소프트웨어를 만드는 데 가장 가치 있는 기술 중 하나는 자제입니다.

뭔가 작동하고, 바꿀 필요가 없다면, 그냥 두세요.

당연하게 들리지만, 따르기 놀랍도록 어렵습니다. 지저분하거나 구식으로 보이는 코드를 보면, '정리'하고 싶을 겁니다. 이 충동에 저항하세요.`,
      principles: [
        {
          principle: "작동하는 코드는 가치가 있다",
          explanation: "작동하는 코드는 테스트, 엣지 케이스, 실제 사용을 견뎌냈습니다. 자리를 얻은 것입니다. 새 코드는 아직 아무것도 증명하지 않았습니다.",
        },
        {
          principle: "모든 변경은 위험이다",
          explanation: "'개선'도 버그를 도입할 수 있습니다. 가장 안전한 코드는 건드리지 않는 코드입니다.",
        },
        {
          principle: "못생겼지만 작동하는 것이 예쁘지만 깨진 것보다 낫다",
          explanation: "사용자는 당신의 코드를 보지 않습니다. 제품이 작동하는지 봅니다. 미학보다 기능을 우선시하세요.",
        },
        {
          principle: "리팩토링은 별도의 작업이다",
          explanation: "코드가 정리가 필요하면, 전용 테스트와 함께 전용 작업으로 하세요—새로운 것을 만드는 부작용으로가 아니라.",
        },
      ],
      whenToTouch: {
        title: "작동하는 코드를 건드려야 할 때:",
        reasons: [
          "바꿔야 하는 것을 추가해야 할 때",
          "사용자에게 영향을 미치는 버그가 있을 때",
          "보안 문제가 있을 때",
          "필요한 것을 만드는 것을 막고 있을 때",
        ],
      },
      mantra: "작동하고 바꿀 필요가 없으면, 건드리지 마세요. 넘어가세요. 대신 새로운 것을 만드세요.",
    },

    askingBetterQuestions: {
      title: "기존 코드에 대해 AI에게 더 좋은 질문하기",
      content: `코드를 이해하지 못할 때, 이해하는 척하지 마세요. AI에게 설명해달라고 하세요.

하지만 설명의 질은 질문의 질에 달려 있습니다. 모호한 질문은 모호한 답을 얻습니다. 구체적인 질문은 유용한 답을 얻습니다.`,
      badVsGood: [
        {
          bad: "이 코드가 뭐 해?",
          good: "이 함수가 무엇을 하는지 일반적인 말로 설명해줘, 프로그래밍을 한 번도 안 해본 사람에게 설명하듯이. 무엇이 들어가고, 무엇이 나오고, 왜 사용하는지?",
          why: "좋은 버전은 AI에게 당신의 맥락(비프로그래머)과 구체적으로 알고 싶은 것(입력, 출력, 목적)을 알려줍니다.",
        },
        {
          bad: "이 코드 좋아?",
          good: "이 코드에 잠재적 문제가 있는지 검토해줘. 위험 신호, 누락된 에러 처리, 문제를 일으킬 수 있는 가정이 있어?",
          why: "좋은 버전은 '좋다'가 무엇을 의미하는지 정의하고 AI에게 확인할 구체적인 것을 줍니다.",
        },
        {
          bad: "왜 이게 안 돼?",
          good: "이 코드가 [예상 동작]을 해야 하는데, 대신 [실제 동작]을 해. 이 차이가 무엇 때문일 수 있어?",
          why: "좋은 버전은 기대한 것 vs 일어난 것에 대한 맥락을 제공합니다—디버깅에 필수적입니다.",
        },
        {
          bad: "이거 개선해줄 수 있어?",
          good: "이 코드를 더 유지보수하기 쉽게 만들고 싶어. 가장 지저분한 부분을 식별하고 어떻게 재구성할지 제안해줄 수 있어?",
          why: "좋은 버전은 '개선'이 당신에게 무엇을 의미하는지 정의하고 작업 범위를 정합니다.",
        },
      ],
      templates: {
        title: "사용할 수 있는 질문 템플릿",
        items: [
          "이 코드를 프로그래머가 아닌 사람에게 설명하듯이 설명해줘. 무엇을 달성하려고 하는 건지?",
          "사용자가 [특정 동작]을 할 때 단계별로 무슨 일이 일어나는지 설명해줘.",
          "이 코드가 어떤 가정을 해? 그 가정이 틀리면 어떻게 돼?",
          "이 코드가 건물이라면, 기초는 뭐고, 방은 뭐고, 어떻게 연결되어 있어?",
          "조건이 바뀌면 취약하거나 깨질 가능성이 있는 부분이 있어?",
          "이것이 어떻게 작동하는지에 대해 내가 이해해야 할 가장 중요한 것은 뭐야?",
        ],
      },
    },

    confidenceStatement: {
      title: "읽기는 쓰기가 아니다",
      content: `이 레벨이 당신에게 요구하는 것—그리고 요구하지 않는 것—에 대해 명확히 합시다.

당신은 코드를 읽는 법을 배우고 있습니다, 쓰는 법이 아닙니다. 이것들은 근본적으로 다른 기술입니다.

읽기는 인식이 필요합니다. 패턴을 보고, 조직을 알아채고, 문제를 발견합니다. 처음부터 아무것도 만들어낼 필요가 없습니다.

쓰기는 생성이 필요합니다. 아무것도 없는 데서 시작해서 문법, 로직, 시스템에 대한 이해로 작동하는 코드를 만듭니다.

이 기술들 사이의 간격은 엄청납니다. 교향곡을 작곡하지 않고도 악보를 읽는 법을 배울 수 있습니다. 건물을 설계하지 않고도 청사진을 읽는 법을 배울 수 있습니다. 프로그램을 작성하지 않고도 코드를 읽는 법을 배울 수 있습니다.

그게 당신입니다. 그리고 그것으로 충분합니다.

이 레벨을 마치면, 프로그래머가 되지 않을 겁니다. 당신의 목적에 더 유용한 뭔가가 됩니다: AI가 만든 것을 보고, 이해되는지 이해하고, 다음에 무엇을 할지 정보에 입각한 결정을 내릴 수 있는 사람.

언제 AI 작업을 신뢰하고 언제 의문을 가질지 알게 됩니다.
언제 변경을 요청하고 언제 그냥 둘지 알게 됩니다.
뭔가 맞아 보일 때와 뭔가 이상하게 느껴질 때 알게 됩니다.

그건 위안상이 아닙니다. 그게 기술입니다. 그게 vibe coding을 작동하게 만드는 것입니다.

성장하는 직관을 신뢰하세요. 사용하세요. 그리고 계속 만드세요.`,
    },
  },

  closing: `이제 이 로드맵의 중간 지점에 도달했습니다.

뒤에: 마인드셋, 문제 정의, 프롬프팅. 만들기에 대해 어떻게 생각하는지, 원하는 것을 설명하는 방법, AI를 지시해서 만들게 하는 방법을 압니다.

앞에: 직접 작은 편집하기, 제품으로 생각하기, 반복 가능한 시스템 구축하기.

하지만 바로 여기, 레벨 3에서, 중요한 것을 얻었습니다: 코드를 보고 의견을 형성할 수 있는 자신감. 전문가 의견이 아닙니다. 기술 면접에서 방어할 의견이 아닙니다. 하지만 작동하는 의견—앞으로 나아가기에 충분하고, 문제를 발견하기에 충분하고, 만들기에 충분합니다.

그것이 다음에 오는 모든 것의 기초입니다.`,
};
