// Korean version of the roadmap overview content
export const VIBE_CODING_ROADMAP_KO = [
  {
    level: 0,
    title: "마인드셋 리셋",
    philosophy: "프로그래머가 될 필요 없습니다. 만드는 사람이 되면 됩니다.",
    willLearn: [
      "vibe coding이 실제로 무엇인지 (그리고 무엇이 아닌지)",
      "AI가 처리하는 것 vs 당신이 책임지는 것",
      "전문 코더가 되지 않아도 되는 이유",
      "코드를 배워야 한다는 두려움 극복하기",
    ],
    willNotLearn: [
      "프로그래밍 언어나 문법 없음",
      "알고리즘이나 자료 구조 없음",
      "아직 도구나 플랫폼 없음",
    ],
    outcome: "자신감 있게 스스로 만들 수 있다고 말할 수 있습니다—프로그래밍을 모른다고 말하지 않아도 됩니다.",
    example: {
      scenario: "시나리오",
      description: "친구가 앱 아이디어를 물어봅니다. 코딩을 배워야 한다고 말하는 대신, 원하는 것을 설명하라고 말합니다. 필요한 건 명확함과 AI뿐이라고 설명합니다.",
    },
  },
  {
    level: 1,
    title: "문제를 말로 정의하기",
    philosophy: "명확하게 설명할 수 있다면, AI가 만들 수 있습니다.",
    willLearn: [
      "모호한 요청이 실패하는 이유",
      "일반 언어로 제품 설명하기",
      "큰 아이디어를 작고 만들 수 있는 부분으로 나누기",
      "뭘 만들지 (그리고 만들지 않을지) 범위 정의하기",
    ],
    willNotLearn: [
      "코드나 기술 도구 없음",
      "프롬프트 엔지니어링 아직 없음",
      "디자인 도구 없음",
    ],
    outcome: "실제로 뭔가를 만들기 전에 만들고 있는 것에 대한 명확한 한 페이지 설명을 쓸 수 있습니다.",
    example: {
      scenario: "시나리오",
      description: "'간단한 예약 페이지'를 원한다고 말하는 대신, 정확히 누가 사용하는지, 뭘 하는지, 뭘 하지 않는지 쓸 수 있습니다—AI가 제대로 만들기 전에.",
    },
  },
  {
    level: 2,
    title: "AI에게 프롬프트로 지시하기",
    philosophy: "AI는 당신의 주니어 개발자입니다. 당신이 매니저입니다.",
    willLearn: [
      "'전부 해줘' 프롬프트가 왜 실패하는지",
      "작업을 단계로 나누기",
      "AI에게 역할 부여하기",
      "적절히 반복하는 방법",
    ],
    willNotLearn: [
      "특정 AI 도구나 플랫폼 없음",
      "고급 프롬프트 기술 없음",
      "API나 자동화 없음",
    ],
    outcome: "AI가 당신이 원하는 것을 생성하게 하는 다단계 프롬프트를 쓸 수 있습니다—작동할 때까지 반복하면서.",
    example: {
      scenario: "시나리오",
      description: "연락 폼을 만들 때, '연락 폼 만들어줘'라고 요청하는 대신 먼저 레이아웃을 요청하고, 그다음 유효성 검사를 추가하고, 그다음 제출 동작을 추가합니다—각 단계를 확인하면서.",
    },
  },
  {
    level: 3,
    title: "코드 읽고 판단하기",
    philosophy: "코드를 작성할 필요 없습니다. 판단할 줄 알면 됩니다.",
    willLearn: [
      "구조 vs 혼돈 인식하기",
      "코드에서 위험 신호 발견하기",
      "언제 건드리고 언제 그냥 둘지",
      "AI에게 더 좋은 질문하기",
    ],
    willNotLearn: [
      "코드 문법 없음",
      "디버깅 기술 없음",
      "언어별 지식 없음",
    ],
    outcome: "AI가 만든 코드를 보고, 구조가 이해되는지 판단하고, 문제처럼 보이는 것을 발견하면 지능적인 질문을 할 수 있습니다.",
    example: {
      scenario: "시나리오",
      description: "AI가 코드를 생성합니다. 모든 줄을 이해하는 대신, 잘 정리되어 있는지, 이상해 보이는 게 있는지, 에러 케이스를 처리하는지 스캔합니다.",
    },
  },
  {
    level: 4,
    title: "최소 변경, 최대 효과",
    philosophy: "작고 집중된 변경이 큰 재작성보다 안전합니다.",
    willLearn: [
      "더 많은 기능이 왜 보통 더 나쁜지",
      "높은 영향력 영역 식별하기",
      "안전하고 되돌릴 수 있는 변경 만들기",
      "AI에게 정확히 원하는 것 전달하기",
    ],
    willNotLearn: [
      "리팩토링 없음",
      "기능 추가 없음",
      "아키텍처 변경 없음",
    ],
    outcome: "버튼 라벨이나 에러 메시지 같은 작고 의미 있는 편집을 할 수 있습니다—불필요하게 작동하는 것을 깨뜨리지 않으면서.",
    example: {
      scenario: "시나리오",
      description: "'앱 개선해줘'라고 요청하는 대신, '이 버튼 텍스트를 <더 명확한 버전>으로 바꿔줘, 다른 건 건드리지 말고'라고 말합니다.",
    },
  },
  {
    level: 5,
    title: "기능이 아닌 제품으로 생각하기",
    philosophy: "기능은 중요하지 않습니다. 실제 사람들에게 해결된 문제가 중요합니다.",
    willLearn: [
      "기능이 왜 가치와 같지 않은지",
      "사용자 의도 이해하기",
      "간단한 사용자 여정 매핑하기",
      "'완료' 정의하기",
    ],
    willNotLearn: [
      "분석 도구 없음",
      "마케팅 전략 없음",
      "성장 해킹 없음",
    ],
    outcome: "사용자 관점에서 프로젝트를 평가할 수 있습니다. 기능 추가가 항상 개선이 아니라는 것을 알고 언제 출시를 멈출지 압니다.",
    example: {
      scenario: "시나리오",
      description: "누군가 '더 많은 필터 추가해야 해'라고 말합니다. '그게 어떤 문제를 해결하지?'라고 물어봅니다. 좋은 답이 없으면, 추가하지 않습니다.",
    },
  },
  {
    level: 6,
    title: "워크플로우 시스템화하기",
    philosophy: "반복 가능한 프로세스가 무작위 생산성 폭발보다 낫습니다.",
    willLearn: [
      "프롬프트를 재사용 가능한 템플릿으로 바꾸기",
      "뭐가 작동했고 안 됐는지 문서화하기",
      "개인 빌드 플레이북 만들기",
      "협업이나 규모 준비하기",
    ],
    willNotLearn: [
      "자동화 도구 없음",
      "팀 관리 없음",
      "비즈니스 운영 없음",
    ],
    outcome: "반복 가능한 빌드 시스템이 있습니다: 체크리스트, 템플릿, 교훈 문서—배운 것 위에 매번 구축하도록 합니다.",
    example: {
      scenario: "시나리오",
      description: "새 프로젝트를 시작할 때, 처음부터 시작하지 않습니다. 체크리스트를 열고, 템플릿을 사용하고, 어디서 시작하는지 정확히 압니다.",
    },
  },
];
